package rrddb

import (
	"os"
	"testing"
	"time"
)

var arname = "/tmp/rrd.tar"
var dbname = "/tmp/rrd.db"
var rrdname = "test"
var step = uint(1)
var heartbeat = 2 * step

func TestAll(t *testing.T) {
	var rd *Rrddb
	var err error

	defer os.Remove(arname)
	defer os.Remove(dbname)

	if rd, err = Open(arname, dbname); err != nil {
		t.Fatal(err)
	}

	// Create
	c := rd.NewCreator(rrdname, time.Now(), step)
	c.RRA("AVERAGE", 0.5, 1, 100)
	c.RRA("AVERAGE", 0.5, 5, 100)
	c.DS("cnt", "COUNTER", heartbeat, 0, 100)
	c.DS("g", "GAUGE", heartbeat, 0, 60)
	err = c.Create(0)
	if err != nil {
		t.Fatal(err)
	}

	if err = rd.Close(); err != nil {
		t.Fatal(err)
	}

	/*

		// Update
		u := NewUpdater(dbfile)
		for i := 0; i < 10; i++ {
			time.Sleep(step * time.Second)
			err := u.Update(time.Now(), i, 1.5*float64(i))
			if err != nil {
				t.Fatal(err)
			}
		}

		// Update with cache
		for i := 10; i < 20; i++ {
			time.Sleep(step * time.Second)
			u.Cache(time.Now(), i, 2*float64(i))
		}
		err = u.Update()
		if err != nil {
			t.Fatal(err)
		}

		// Info
		inf, err := Info(dbfile)
		if err != nil {
			t.Fatal(err)
		}
		for k, v := range inf {
			fmt.Printf("%s (%T): %v\n", k, v, v)
		}

		// Fetch
		end := time.Unix(int64(inf["last_update"].(uint)), 0)
		start := end.Add(-20 * step * time.Second)
		fmt.Printf("Fetch Params:\n")
		fmt.Printf("Start: %s\n", start)
		fmt.Printf("End: %s\n", end)
		fmt.Printf("Step: %s\n", step*time.Second)
		fetchRes, err := Fetch(dbfile, "AVERAGE", start, end, step*time.Second)
		if err != nil {
			t.Fatal(err)
		}
		defer fetchRes.FreeValues()
		fmt.Printf("FetchResult:\n")
		fmt.Printf("Start: %s\n", fetchRes.Start)
		fmt.Printf("End: %s\n", fetchRes.End)
		fmt.Printf("Step: %s\n", fetchRes.Step)
		for _, dsName := range fetchRes.DsNames {
			fmt.Printf("\t%s", dsName)
		}
		fmt.Printf("\n")

		row := 0
		for ti := fetchRes.Start.Add(fetchRes.Step); ti.Before(end) || ti.Equal(end); ti = ti.Add(fetchRes.Step) {
			fmt.Printf("%s / %d", ti, ti.Unix())
			for i := 0; i < len(fetchRes.DsNames); i++ {
				v := fetchRes.ValueAt(i, row)
				fmt.Printf("\t%e", v)
			}
			fmt.Printf("\n")
			row++
		}
	*/
}
